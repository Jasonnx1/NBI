public class Voronoi
{

int nVoronoi = 200;
color[] seed_colors = new color[nVoronoi];


ArrayList<PVector> nodes;

int minDistance = 0;
int minIndex = 0;

Voronoi()
{
  nodes = new ArrayList<PVector>();
}




void generateMap()
{

    for(int i=0; i < nVoronoi; i++)
    {
      
        nodes.add(new PVector((int)random(20, width - 20), (int)random(20, height - 20) ) );
        seed_colors[i] = color(60,random(20, 70),100);
        
      
    }
  
}

void display()
{
   // For each pixel
    for(int px = 0; px < width; px++)
    {
         for(int py = 0; py < height; py++)
         {
             // Check distances to colors
             minDistance = ((px  - (int)(nodes.get(0).x) ) * (px - (int)(nodes.get(0).x))) +  ((py  - (int)(nodes.get(0).y)) * (py  - (int)(nodes.get(0).y)));
             minIndex = 0;

             for (int nc = 0; nc < nVoronoi; nc++)
             {
                 int dist = ((px  - (int)(nodes.get(nc).x) ) * (px - (int)(nodes.get(nc).x))) +  ((py  - (int)(nodes.get(nc).x)) * (py  - (int)(nodes.get(nc).x)));
                 
                 if (dist <= minDistance)
                 {
                     minDistance = dist;
                     minIndex = nc;
                }
              
            }
            // Distance has been picked. Color!
            set(px, py, seed_colors[minIndex]);
            

        }
    }
  
    
    noStroke();
    fill(0);
  
    for (int nc = 0; nc < nVoronoi; nc++)
    {        
       ellipse((int)nodes.get(nc).x, (int)nodes.get(nc).y , 3, 3);     
    }
  
  
}


}
